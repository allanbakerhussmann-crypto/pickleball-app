/**
 * Standing Meetups Service
 *
 * CRUD operations for standing meetups (recurring weekly sessions).
 * Note: Occurrences and participants are managed by Cloud Functions.
 *
 * @version 07.53
 * @file services/firebase/standingMeetups.ts
 */

import {
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit,
  onSnapshot,
  Unsubscribe,
  increment,
} from '@firebase/firestore';
import { db } from './index';
import {
  StandingMeetup,
  MeetupOccurrence,
  MeetupOccurrenceIndex,
  OccurrenceParticipant,
} from '../../types/standingMeetup';

// =============================================================================
// Collection References
// =============================================================================

const STANDING_MEETUPS_COLLECTION = 'standingMeetups';
const OCCURRENCES_SUBCOLLECTION = 'occurrences';
const PARTICIPANTS_SUBCOLLECTION = 'participants';
const INDEX_COLLECTION = 'meetupOccurrencesIndex';

// =============================================================================
// Standing Meetup CRUD
// =============================================================================

/**
 * Get a standing meetup by ID
 */
export async function getStandingMeetup(
  standingMeetupId: string
): Promise<StandingMeetup | null> {
  const docRef = doc(db, STANDING_MEETUPS_COLLECTION, standingMeetupId);
  const docSnap = await getDoc(docRef);

  if (!docSnap.exists()) {
    return null;
  }

  return { id: docSnap.id, ...docSnap.data() } as StandingMeetup;
}

/**
 * Get all standing meetups for a club
 */
export async function getStandingMeetupsByClub(
  clubId: string,
  options?: {
    status?: StandingMeetup['status'];
    limit?: number;
  }
): Promise<StandingMeetup[]> {
  let q = query(
    collection(db, STANDING_MEETUPS_COLLECTION),
    where('clubId', '==', clubId),
    orderBy('createdAt', 'desc')
  );

  if (options?.status) {
    q = query(
      collection(db, STANDING_MEETUPS_COLLECTION),
      where('clubId', '==', clubId),
      where('status', '==', options.status),
      orderBy('createdAt', 'desc')
    );
  }

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  const snapshot = await getDocs(q);
  return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as StandingMeetup));
}

/**
 * Get public standing meetups for discovery feed
 */
export async function getPublicStandingMeetups(
  options?: {
    limit?: number;
  }
): Promise<StandingMeetup[]> {
  let q = query(
    collection(db, STANDING_MEETUPS_COLLECTION),
    where('status', '==', 'active'),
    where('visibility', '==', 'public'),
    orderBy('createdAt', 'desc')
  );

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  const snapshot = await getDocs(q);
  return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as StandingMeetup));
}

/**
 * Create a new standing meetup
 * Note: Occurrences are generated by Cloud Functions after creation
 */
export async function createStandingMeetup(
  data: Omit<StandingMeetup, 'id' | 'createdAt' | 'updatedAt' | 'subscriberCount'>
): Promise<string> {
  const docRef = doc(collection(db, STANDING_MEETUPS_COLLECTION));
  const now = Date.now();

  const meetup: StandingMeetup = {
    ...data,
    id: docRef.id,
    subscriberCount: 0,
    createdAt: now,
    updatedAt: now,
  };

  await setDoc(docRef, meetup);
  return docRef.id;
}

/**
 * Update a standing meetup
 */
export async function updateStandingMeetup(
  standingMeetupId: string,
  data: Partial<Omit<StandingMeetup, 'id' | 'createdAt'>>
): Promise<void> {
  const docRef = doc(db, STANDING_MEETUPS_COLLECTION, standingMeetupId);
  await updateDoc(docRef, {
    ...data,
    updatedAt: Date.now(),
  });
}

/**
 * Archive a standing meetup (soft delete)
 */
export async function archiveStandingMeetup(standingMeetupId: string): Promise<void> {
  await updateStandingMeetup(standingMeetupId, { status: 'archived' });
}

/**
 * Delete a standing meetup (hard delete - use with caution)
 */
export async function deleteStandingMeetup(standingMeetupId: string): Promise<void> {
  const docRef = doc(db, STANDING_MEETUPS_COLLECTION, standingMeetupId);
  await deleteDoc(docRef);
}

/**
 * Subscribe to standing meetup updates
 */
export function subscribeToStandingMeetup(
  standingMeetupId: string,
  callback: (meetup: StandingMeetup | null) => void
): Unsubscribe {
  const docRef = doc(db, STANDING_MEETUPS_COLLECTION, standingMeetupId);

  return onSnapshot(
    docRef,
    (docSnap) => {
      if (!docSnap.exists()) {
        callback(null);
        return;
      }
      callback({ id: docSnap.id, ...docSnap.data() } as StandingMeetup);
    },
    (error) => {
      // Handle Firestore SDK errors gracefully (known bug in v12.6.0)
      console.debug('Standing meetup subscription error (safe to ignore):', error.message);
      callback(null);
    }
  );
}

/**
 * Subscribe to standing meetups for a club
 */
export function subscribeToClubStandingMeetups(
  clubId: string,
  callback: (meetups: StandingMeetup[]) => void,
  options?: { status?: StandingMeetup['status'] }
): Unsubscribe {
  let q = query(
    collection(db, STANDING_MEETUPS_COLLECTION),
    where('clubId', '==', clubId),
    orderBy('createdAt', 'desc')
  );

  if (options?.status) {
    q = query(
      collection(db, STANDING_MEETUPS_COLLECTION),
      where('clubId', '==', clubId),
      where('status', '==', options.status),
      orderBy('createdAt', 'desc')
    );
  }

  return onSnapshot(
    q,
    (snapshot) => {
      const meetups = snapshot.docs.map(
        (doc) => ({ id: doc.id, ...doc.data() } as StandingMeetup)
      );
      callback(meetups);
    },
    (error) => {
      // Handle Firestore SDK errors gracefully (known bug in v12.6.0)
      console.debug('Club standing meetups subscription error (safe to ignore):', error.message);
      callback([]);
    }
  );
}

// =============================================================================
// Occurrence Read Operations (Cloud Functions handle writes)
// =============================================================================

/**
 * Get an occurrence by ID
 */
export async function getOccurrence(
  standingMeetupId: string,
  dateId: string
): Promise<MeetupOccurrence | null> {
  const docRef = doc(
    db,
    STANDING_MEETUPS_COLLECTION,
    standingMeetupId,
    OCCURRENCES_SUBCOLLECTION,
    dateId
  );
  const docSnap = await getDoc(docRef);

  if (!docSnap.exists()) {
    return null;
  }

  return { id: docSnap.id, ...docSnap.data() } as MeetupOccurrence;
}

/**
 * Get upcoming occurrences for a standing meetup
 */
export async function getUpcomingOccurrences(
  standingMeetupId: string,
  options?: { limit?: number }
): Promise<MeetupOccurrence[]> {
  const now = Date.now();
  let q = query(
    collection(
      db,
      STANDING_MEETUPS_COLLECTION,
      standingMeetupId,
      OCCURRENCES_SUBCOLLECTION
    ),
    where('startAt', '>=', now),
    where('status', 'in', ['scheduled', 'in_progress']),
    orderBy('startAt', 'asc')
  );

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  const snapshot = await getDocs(q);
  return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as MeetupOccurrence));
}

/**
 * Get past occurrences for a standing meetup
 */
export async function getPastOccurrences(
  standingMeetupId: string,
  options?: { limit?: number }
): Promise<MeetupOccurrence[]> {
  const now = Date.now();
  let q = query(
    collection(
      db,
      STANDING_MEETUPS_COLLECTION,
      standingMeetupId,
      OCCURRENCES_SUBCOLLECTION
    ),
    where('startAt', '<', now),
    orderBy('startAt', 'desc')
  );

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  const snapshot = await getDocs(q);
  return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as MeetupOccurrence));
}

/**
 * Subscribe to occurrences for a standing meetup
 */
export function subscribeToOccurrences(
  standingMeetupId: string,
  callback: (occurrences: MeetupOccurrence[]) => void,
  options?: { upcoming?: boolean; limit?: number }
): Unsubscribe {
  const now = Date.now();
  let q = query(
    collection(
      db,
      STANDING_MEETUPS_COLLECTION,
      standingMeetupId,
      OCCURRENCES_SUBCOLLECTION
    ),
    orderBy('startAt', options?.upcoming ? 'asc' : 'desc')
  );

  if (options?.upcoming) {
    q = query(
      collection(
        db,
        STANDING_MEETUPS_COLLECTION,
        standingMeetupId,
        OCCURRENCES_SUBCOLLECTION
      ),
      where('startAt', '>=', now),
      orderBy('startAt', 'asc')
    );
  }

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  return onSnapshot(
    q,
    (snapshot) => {
      const occurrences = snapshot.docs.map(
        (doc) => ({ id: doc.id, ...doc.data() } as MeetupOccurrence)
      );
      callback(occurrences);
    },
    (error) => {
      // Handle Firestore SDK errors gracefully (known bug in v12.6.0)
      console.debug('Occurrences subscription error (safe to ignore):', error.message);
      callback([]);
    }
  );
}

// =============================================================================
// Participant Read Operations (Cloud Functions handle writes)
// =============================================================================

/**
 * Get a participant from an occurrence
 */
export async function getParticipant(
  standingMeetupId: string,
  dateId: string,
  userId: string
): Promise<OccurrenceParticipant | null> {
  const docRef = doc(
    db,
    STANDING_MEETUPS_COLLECTION,
    standingMeetupId,
    OCCURRENCES_SUBCOLLECTION,
    dateId,
    PARTICIPANTS_SUBCOLLECTION,
    userId
  );
  const docSnap = await getDoc(docRef);

  if (!docSnap.exists()) {
    return null;
  }

  return docSnap.data() as OccurrenceParticipant;
}

/**
 * Get all participants for an occurrence
 */
export async function getOccurrenceParticipants(
  standingMeetupId: string,
  dateId: string
): Promise<Array<OccurrenceParticipant & { odUserId: string }>> {
  const q = query(
    collection(
      db,
      STANDING_MEETUPS_COLLECTION,
      standingMeetupId,
      OCCURRENCES_SUBCOLLECTION,
      dateId,
      PARTICIPANTS_SUBCOLLECTION
    )
  );

  const snapshot = await getDocs(q);
  return snapshot.docs.map((doc) => ({
    odUserId: doc.id,
    ...(doc.data() as OccurrenceParticipant),
  }));
}

/**
 * Subscribe to participants for an occurrence
 */
export function subscribeToOccurrenceParticipants(
  standingMeetupId: string,
  dateId: string,
  callback: (participants: Array<OccurrenceParticipant & { odUserId: string }>) => void
): Unsubscribe {
  const q = query(
    collection(
      db,
      STANDING_MEETUPS_COLLECTION,
      standingMeetupId,
      OCCURRENCES_SUBCOLLECTION,
      dateId,
      PARTICIPANTS_SUBCOLLECTION
    )
  );

  return onSnapshot(
    q,
    (snapshot) => {
      const participants = snapshot.docs.map((doc) => ({
        odUserId: doc.id,
        ...(doc.data() as OccurrenceParticipant),
      }));
      callback(participants);
    },
    (error) => {
      // Handle Firestore SDK errors gracefully (known bug in v12.6.0)
      console.debug('Occurrence participants subscription error (safe to ignore):', error.message);
      callback([]);
    }
  );
}

// =============================================================================
// Index Read Operations (Discovery Feed)
// =============================================================================

/**
 * Get upcoming occurrences from the flat index (for discovery feed)
 */
export async function getUpcomingOccurrenceIndex(
  options?: {
    clubId?: string;
    limit?: number;
  }
): Promise<MeetupOccurrenceIndex[]> {
  const now = Date.now();
  let q = query(
    collection(db, INDEX_COLLECTION),
    where('when', '>=', now),
    where('status', '==', 'scheduled'),
    orderBy('when', 'asc')
  );

  if (options?.clubId) {
    q = query(
      collection(db, INDEX_COLLECTION),
      where('clubId', '==', options.clubId),
      where('when', '>=', now),
      where('status', '==', 'scheduled'),
      orderBy('when', 'asc')
    );
  }

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  const snapshot = await getDocs(q);
  return snapshot.docs.map(
    (doc) => ({ id: doc.id, ...doc.data() } as MeetupOccurrenceIndex)
  );
}

/**
 * Subscribe to upcoming occurrences from the index
 */
export function subscribeToOccurrenceIndex(
  callback: (occurrences: MeetupOccurrenceIndex[]) => void,
  options?: {
    clubId?: string;
    limit?: number;
  }
): Unsubscribe {
  const now = Date.now();
  let q = query(
    collection(db, INDEX_COLLECTION),
    where('when', '>=', now),
    where('status', '==', 'scheduled'),
    orderBy('when', 'asc')
  );

  if (options?.clubId) {
    q = query(
      collection(db, INDEX_COLLECTION),
      where('clubId', '==', options.clubId),
      where('when', '>=', now),
      where('status', '==', 'scheduled'),
      orderBy('when', 'asc')
    );
  }

  if (options?.limit) {
    q = query(q, limit(options.limit));
  }

  return onSnapshot(
    q,
    (snapshot) => {
      const occurrences = snapshot.docs.map(
        (doc) => ({ id: doc.id, ...doc.data() } as MeetupOccurrenceIndex)
      );
      callback(occurrences);
    },
    (error) => {
      // Handle Firestore SDK errors gracefully (known bug in v12.6.0)
      console.debug('Occurrence index subscription error (safe to ignore):', error.message);
      callback([]);
    }
  );
}

// =============================================================================
// User's Upcoming Sessions (across all subscriptions)
// =============================================================================

/**
 * Get user's upcoming sessions as a participant
 * This queries the index and filters by user's subscriptions
 */
export async function getUserUpcomingSessions(
  userId: string,
  subscriptionMeetupIds: string[],
  options?: { limit?: number }
): Promise<MeetupOccurrenceIndex[]> {
  if (subscriptionMeetupIds.length === 0) {
    return [];
  }

  const now = Date.now();
  // Firestore 'in' query has a limit of 10 items
  const chunks: string[][] = [];
  for (let i = 0; i < subscriptionMeetupIds.length; i += 10) {
    chunks.push(subscriptionMeetupIds.slice(i, i + 10));
  }

  const results: MeetupOccurrenceIndex[] = [];

  for (const chunk of chunks) {
    const q = query(
      collection(db, INDEX_COLLECTION),
      where('standingMeetupId', 'in', chunk),
      where('when', '>=', now),
      where('status', '==', 'scheduled'),
      orderBy('when', 'asc'),
      limit(options?.limit ?? 20)
    );

    const snapshot = await getDocs(q);
    results.push(
      ...snapshot.docs.map(
        (doc) => ({ id: doc.id, ...doc.data() } as MeetupOccurrenceIndex)
      )
    );
  }

  // Sort by when and apply limit
  results.sort((a, b) => a.when - b.when);
  if (options?.limit) {
    return results.slice(0, options.limit);
  }

  return results;
}
